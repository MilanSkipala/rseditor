#include "application.h"
#include "partsRelated.h"

ModelFragmentWidget::ModelFragmentWidget()
{
    this->endPoints = new QList<QPoint *>();
    this->endPointsAngles = new QList <qreal>();
    this->fragmentItems = new QList <ModelItem*>();
    this->lines = new QList <ProductLine*>();
    this->startPoint = NULL;
    this->startPointAngle = 0;

}

ModelFragmentWidget::ModelFragmentWidget(ModelItem* item, ProductLine* line, QPoint * startPt,QList<QPoint *> *endPts,QList<qreal> * endPtAngles)
{
    this->endPoints = endPts;
    this->endPointsAngles = endPtAngles;
    this->fragmentItems = new QList <ModelItem*>();
    this->lines = new QList <ProductLine*>();
    this->startPoint = startPt;
    this->startPointAngle = 0;
    this->fragmentItems->push_back(item);
    this->lines->push_back(line);


}


QList <ModelItem*> * ModelFragmentWidget::getFragmentItems() const
{
    return this->fragmentItems;
}

QList<ProductLine*> * ModelFragmentWidget::getProductLines() const
{
    return this->lines;
}

QPoint * ModelFragmentWidget::getStartPoint() const
{
    return this->startPoint;
}

QList<QPoint *> * ModelFragmentWidget::getEndPoints() const
{
    return this->endPoints;
}

qreal ModelFragmentWidget::getStartPointAngle()
{
    return this->startPointAngle;
}

QList<qreal> * ModelFragmentWidget::getEndPointsAngles() const
{
    return this->endPointsAngles;
}

int ModelFragmentWidget::addFragmentItems(QList <ModelItem*> * listToAppend)
{
    if (listToAppend==NULL)
        return 1;
    this->fragmentItems->append(*listToAppend);
    return 0;
}

int ModelFragmentWidget::addFragmentItem(ModelItem* item)
{
    if (item == NULL)
        return 1;
    this->fragmentItems->push_back(item);
    return 0;
}

int ModelFragmentWidget::setStartPoint(QPoint * pt)
{
    if (pt==NULL)
        return 1;
    this->startPoint=pt;
    return 0;
}

int ModelFragmentWidget::addEndPoints (QList<QPoint *> * listToAppend)
{
    if (listToAppend==NULL)
        return 1;
    this->endPoints->append(*listToAppend);
    return 0;
}

int ModelFragmentWidget::removeEndPoint (QPoint * pt)
{
    if (pt == NULL)
        return 1;
    bool success = this->endPoints->removeOne(pt);
    if (success)
        return 0;
    else
        return 2;
}

int ModelFragmentWidget::removeEndPoint (int index)
{
    if (index < 0 || index >= this->endPoints->size())
        return 1;
    this->endPoints->removeAt(index);
    return 0;
}

int ModelFragmentWidget::removeStartPoint()
{
    delete this->startPoint;
    this->startPoint=NULL;
    return 0;
}

int ModelFragmentWidget::setStartPointAngle(qreal angle)
{
    this->startPointAngle = angle;
    return 0;
}

int ModelFragmentWidget::setEndPointAngle(QPoint * pt, qreal angle)
{
    if (pt==NULL)
        return 1;
    int index = this->endPoints->indexOf(pt);
    if (index==-1) //??
        return 2;
    //this->endPointsAngles->at(index)=angle;
    QList<qreal>::Iterator iter = this->endPointsAngles->begin();
    for (int i = 0; i <= index; i++)
        iter++;
    *iter=angle;

    return 0;
}

int ModelFragmentWidget::setEndPointAngle(int index, qreal angle)
{
    QList<qreal>::Iterator iter = this->endPointsAngles->begin();
    if (index < 0 || index >=this->endPointsAngles->size())
        return 1;
    for (int i = 0; i <= index; i++)
        iter++;
    *iter=angle;
    return 0;
}

//ModelItem::ModelItem(QString * partNumber, QString * partNameEn, QString * partNameCs,
//                     QPoint * start, QPoint * end ,qreal degree, qreal turnRadius,
//                     void * appPointer, QWidget * parentWidg, QGraphicsItem * contourParent)

ModelItem::ModelItem(QString & partNumber, QString & partNameEn, QString & partNameCs,
                     QPoint & start, QPoint & end ,qreal degree,
                     qreal turnRadius, QWidget * parentWidg ,QGraphicsItem * contourParent) : QWidget (parentWidg)
{
    //this->app_ptr = appPointer;

    this->parentWidget = parentWidg;
    this->partNo = new QString(partNumber);
    this->nameEn = new QString(partNameEn);
    this->nameCs = new QString(partNameCs);
    this->startPoint = new QPoint(start);
    this->endPoint = new QPoint(end);
    this->turnDegree=degree;
    this->radius=turnRadius;
    this->displayLabel=true;
    this->availableCount=10;





    //this->label = new QLabel(parentWidg);
    this->label = new QLabel(parentWidg);
    /*
    if (app_ptr->getUserPreferences()->getLocale()="Cs")
        this->label->setText(this->nameCs);
    else
        this->label->setText(this->nameEn);
*/
    this->label->setText("Ahoj");

    ///incorrect
    this->glModel = new QGLWidget();



}

QString * ModelItem::getPartNo() const
{
    return this->partNo;
}
QString * ModelItem::getNameEn() const
{
    return this->nameEn;
}
QString * ModelItem::getNameCs() const
{
    return this->nameCs;
}
QPoint * ModelItem::getStartPoint() const
{
    return this->startPoint;
}
QPoint * ModelItem::getEndPoint() const
{
    return this->endPoint;
}

qreal ModelItem::getTurnDegree() const
{
    return this->turnDegree;
}
qreal ModelItem::getRadius() const
{
    return this->radius;
}

QGraphicsPathItem * ModelItem::get2DModel() const
{
    return this->contourModel;
}

int ModelItem::set2DModel(QGraphicsPathItem *model)
{
    if (model==NULL)
        return 1;
    this->contourModel=model;
    return 0;
}

unsigned int ModelItem::getAvailableCount() const
{
    return this->availableCount;
}

void ModelItem::setAvailableCount(unsigned int count)
{
    this->availableCount=count;
}

void ModelItem::incrAvailableCount()
{
    ++this->availableCount;
}

void ModelItem::decrAvailableCount()
{
    --this->availableCount;
}

void ModelItem::displayLabelToggle(bool display)
{
    this->displayLabel=display;
}
void ModelItem::moveLabel(QPoint * point)
{
    this->label->move(*point);
}

GraphicsPathItem::GraphicsPathItem(QGraphicsItem * parent) : QGraphicsPathItem(parent)
{
    this->mouseMoveOffset = new QPointF(0,0);
    this->setFlag(QGraphicsItem::ItemIsMovable,true);
    this->setFlag(QGraphicsItem::ItemIsSelectable,true);
}
GraphicsPathItem::GraphicsPathItem(const QPainterPath & path, QGraphicsItem * parent) : QGraphicsPathItem(path,parent)
{
    this->mouseMoveOffset = new QPointF(0,0);
}

/*
void GraphicsPathItem::mousePressEvent(QGraphicsSceneMouseEvent *event)
{
    //QGraphicsPathItem::mousePressEvent(event);
    //QGraphicsScene::mousePressEvent(event);

    if (this->contains(event->pos()))
        *(this->mouseMoveOffset) = event->pos();
/*
    QPen p = this->pen();
    p.setWidth(15);
    p.setColor(Qt::black);
    this->setPen(p);

    QBrush b = this->brush();
    b.setColor(Qt::yellow);
    this->setBrush(b);

    if ((event->pos().x()>this->pos().x() ||event->pos().y()>this->pos().y()))
    {
        p.setColor(Qt::yellow);
        this->setPen(p);

    }

  * /
    this->update();
    //QGraphicsItem::mousePressEvent(event);



}
void GraphicsPathItem::mouseReleaseEvent(QGraphicsSceneMouseEvent *event)
{
    //QGraphicsPathItem::mouseReleaseEvent(event);
    //QGraphicsScene::mouseReleaseEvent(event);
    /*
    QPen p = this->pen();
    p.setWidth(5);
    this->setPen(p);

    QBrush b = this->brush();
    b.setColor(Qt::red);
    this->setBrush(b);
    * /
    QGraphicsPathItem::mouseReleaseEvent(event);
}

void GraphicsPathItem::mouseMoveEvent(QGraphicsSceneMouseEvent *event)
{
    //QGraphicsPathItem::mouseMoveEvent(event);
    //QGraphicsScene::mouseMoveEvent(event);

    this->moveBy(event->pos().x()-this->mouseMoveOffset->x(),event->pos().y()-this->mouseMoveOffset->y());
    this->update();
}
*/


bool GraphicsPathItem::contains(const QPointF &point) const
{
    return this->path().boundingRect().contains(point);
    //return QRectF(this->pos().x(),this->pos().y(),100,64).contains(point);

}

QRectF GraphicsPathItem::boundingRect() const
{
    //return QRectF(this->pos().x(),this->pos().y(),100,64);
    return this->path().controlPointRect();
}

QPainterPath GraphicsPathItem::shape() const
{
    QPainterPath * p = new QPainterPath();
    p->addRect(this->path().controlPointRect());
    //->addRect(this->pos().x(),this->pos().y(),100,64);
    return *p;
}



ProductLine::ProductLine(QString &name,QString &scale, QString &gauge, bool type, QList<ModelItem*> &items)
{
    this->name=new QString(name);
    this->scale=new QString(scale);
    this->type=type;
    this->gauge=new QString(gauge);
    this->items=new QList<ModelItem*>(items);
    this->maxTrackRadius=0;
    this->minTrackRadius=50000;

}
ProductLine::ProductLine(QString &name,QString &scale, QString &gauge, bool type)
{
    this->name=new QString(name);
    this->scale=new QString(scale);
    this->type=type;
    this->items = new QList<ModelItem*>();
    this->maxTrackRadius=0;
    this->minTrackRadius=50000;
}


QString * ProductLine::getName() const
{
    return this->name;
}

QString * ProductLine::getScale() const
{
    return this->scale;
}

bool ProductLine::getType() const
{
    return this->type;
}

QList<ModelItem*> * ProductLine::getItemsList() const
{
    return this->items;
}

int ProductLine::setItemsList(QList<ModelItem*>* list)
{
    return 0;
}

int ProductLine::addItem(ModelItem* item)
{
    if (item==NULL)
        return 1;
    this->items->push_back(item);
    if (item->getRadius()>this->maxTrackRadius)
        this->maxTrackRadius=item->getRadius();

    if(item->getRadius()<this->minTrackRadius)
        this->minTrackRadius=item->getRadius();

    return 0;
}

int ProductLine::generate2DModels()
{
    QList<ModelItem*>::Iterator iter = this->items->begin();
    while (iter!=this->items->end())
    {
        /*
         *this cannot be used - doesn't preserve scale of one product line
         *

        qreal normalized = (this->maxTrackRadius-(*iter)->getRadius())/(this->maxTrackRadius-this->minTrackRadius);
        normalized = 1 - 0.2*normalized;
        int sizeOfItem = 32;
        QRectF rectOuter(-sizeOfItem*normalized,-sizeOfItem*normalized,sizeOfItem*normalized*2,sizeOfItem*normalized*2);
        sizeOfItem=24;
        QRectF rectInner(-sizeOfItem*normalized,-sizeOfItem*normalized,sizeOfItem*normalized*2,sizeOfItem*normalized*2);
        */





        QRectF rectOuter(-(*iter)->getRadius()+32,-(*iter)->getRadius()+32,(*iter)->getRadius()*2-64,(*iter)->getRadius()*2-64);
        QRectF rectInner(-(*iter)->getRadius()+24,-(*iter)->getRadius()+24,(*iter)->getRadius()*2-48,(*iter)->getRadius()*2-48);



        /**
          *TODO
          *-positioning of items in scene
          *-restricted mode
          *-text is added to path - it means the text will be displayed also in wswidget - how to hide it?
            */


        QPainterPath itemPath;

        qreal startAngle = 90-((*iter)->getTurnDegree()/2);

        QFont font;
        font.setPixelSize(10);
        QString label(*(*iter)->getPartNo());
        label.append(" ");
        QString s("");
        if ((*iter)->getTurnDegree()!=0)
            s.setNum((*iter)->getTurnDegree(),'f',1);
        else
            s.setNum((*iter)->getTurnDegree(),'f',0);

        label.append(s);
        label.append("Â° ");
        s.setNum((*iter)->getRadius());
        label.append(s);



        itemPath.addText(-(6*label.length())/2,48-(*iter)->getRadius(),font,label);

        if ((*iter)->getTurnDegree()!=0)
        {
            itemPath.arcMoveTo(rectOuter,startAngle);
            itemPath.arcTo(rectOuter,startAngle,(*iter)->getTurnDegree());
            itemPath.arcMoveTo(rectInner,startAngle);
            itemPath.arcTo(rectInner,startAngle,(*iter)->getTurnDegree());
        }
        else
        {
            QPolygon line;
            line << QPoint(-(*iter)->getRadius()/2,-(*iter)->getRadius()/2);
            line << QPoint((*iter)->getRadius()/2,-(*iter)->getRadius()/2);
            QPolygon line2;
            line2 << QPoint(-(*iter)->getRadius()/2,-(*iter)->getRadius()/2+8);
            line2 << QPoint((*iter)->getRadius()/2,-(*iter)->getRadius()/2+8);

            itemPath.addPolygon(line);
            itemPath.addPolygon(line2);
        }



        GraphicsPathItem * gpi = new GraphicsPathItem();
        gpi->setFlag(QGraphicsItem::ItemIsMovable,true);
        gpi->setFlag(QGraphicsItem::ItemIsSelectable,true);
        gpi->setBoundingRegionGranularity(0.0);
        gpi->setFlag(QGraphicsItem::ItemClipsToShape,false);


        gpi->setPath(itemPath);



        (*iter)->set2DModel(gpi);

        iter++;
    }
    return 0;
}
